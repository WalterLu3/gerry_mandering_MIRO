--- Job Gerrymander.gms Start 02/05/21 02:56:09 32.2.0 rc62c018 DEX-DEG x86 64bit/Mac OS X
--- Applying:
    /Library/Frameworks/GAMS.framework/Versions/32/Resources/gmsprmun.txt
--- GAMS Parameters defined
    Input /Users/walter/Desktop/grad_research/miro_app/gerry_mandering_MIRO/Gerrymander.gms
    PageSize 0
    ScrDir /Users/walter/Desktop/grad_research/miro_app/gerry_mandering_MIRO/225a/
    SysDir /Library/Frameworks/GAMS.framework/Versions/32/Resources/
    LogOption 3
    ErrMsg 1
    ErrorLog 99
    IDE 1
    LstTitleLeftAligned 1
    IDCGenerateJSON conf_Gerrymander/Gerrymander_io.json
    IDCGenerateGDX data_Gerrymander/default.gdx
GAMS 32.2.0   Copyright (C) 1987-2020 GAMS Development. All rights reserved
Licensee: Introduction to Optimization (CS/ISyE/ECE 524) S200826/0001AB-GEN
          University of Wisconsin-Madison, Computer Sciences Dept.   DCE850
          /Users/walter/Library/Application Support/GAMS/gamslice.txt
          Evaluation license: Not for commercial or production use
--- Starting compilation
--- Gerrymander.gms(17) 3 Mb
--- GDXin=/Users/walter/Desktop/grad_research/miro_app/gerry_mandering_MIRO/adjaceny_AZ.gdx
--- Gerrymander.gms(26) 3 Mb
--- GDXin=/Users/walter/Desktop/grad_research/miro_app/gerry_mandering_MIRO/county_vote_AZ.gdx
--- Gerrymander.gms(164) 3 Mb
--- Resetting table request for foo due to external input request for domain nodes.
--- Starting execution: elapsed 0:00:00.046
--- Gerrymander.gms(48) 4 Mb
--- Generating MINLP model spanning_tree
--- Gerrymander.gms(157) 6 Mb
---   730 rows  334 columns  4,435 non-zeroes
---   13 nl-code  6 nl-non-zeroes
---   138 discrete-columns
--- Gerrymander.gms(157) 4 Mb
--- Executing DICOPT (Solvelink=2): elapsed 0:00:00.095
-------------------------------------------------------------------------------
Dicopt 2         32.2.0 rc62c018 Released Aug 26, 2020 DEG x86 64bit/Mac OS X 
-------------------------------------------------------------------------------
by Aldo Vecchietti, Director del Instituto INGAR,
   CONICET, UTN, Santa Fe, Argentina
by Ignacio E. Grossmann, Chemical Engineering Faculty,
   Carnegie Mellon University, Pittsburgh, PA, USA
-------------------------------------------------------------------------------
--- DICOPT: Starting major iteration 1
--- DICOPT: Setting up first (relaxed) NLP.
CONOPT 3         32.2.0 rc62c018 Released Aug 26, 2020 DEG x86 64bit/Mac OS X 
 
 
    C O N O P T 3   version 3.17L
    Copyright (C)   ARKI Consulting and Development A/S
                    Bagsvaerdvej 246 A
                    DK-2880 Bagsvaerd, Denmark
 
 
   Iter Phase Ninf   Infeasibility   RGmax    NSB   Step InItr MX OK
      0   0        2.4000000000E+01 (Input point)
 
                   Pre-triangular equations:   0
                   Post-triangular equations:  4
 
      1   0        2.4000000000E+01 (After pre-processing)
      2   0        2.1000000000E+01 (After scaling)
      3   1    18  1.3500000000E+01 2.2E+03     3 1.0E+00    3 T  T
      4   1    15  7.6601020408E+00 1.5E+01    39 1.0E+00    8 T  T
 
 ** Feasible solution. Value of objective =    1.71372210331
 
   Iter Phase Ninf     Objective     RGmax    NSB   Step InItr MX OK
      5   3        5.9021657983E+01 5.2E+01    44 1.0E+00   12 T  T
      6   3        9.4674829118E+01 5.5E+01    58 1.0E+00   17 T  T
      7   3        9.8606823695E+01 3.7E+00    52 1.0E+00   27 T  T
      8   3        1.0000000000E+02 1.8E+00    42 1.0E+00   22 T  T
      9   3        1.0000000000E+02 0.0E+00     0
 
 ** Optimal solution. There are no superbasic variables.
 
--- DICOPT: Setting up first MIP
IBM ILOG CPLEX   32.2.0 rc62c018 Released Aug 26, 2020 DEG x86 64bit/Mac OS X 
--- GAMS/Cplex Link licensed for continuous and discrete problems.
Cplex 12.10.0.0
3: *** Value Error Value brought in range for option "itlim" saw "2147483638"
3: *** Value Error    Value set to 2100000000
Reading data...
Starting Cplex...
Unable to load names.
Version identifier: 12.10.0.0 | 2019-11-26 | 843d4de
CPXPARAM_Advance                                 0
CPXPARAM_Threads                                 1
CPXPARAM_Parallel                                1
CPXPARAM_MIP_Display                             4
CPXPARAM_TimeLimit                               9999999999.9599991
CPXPARAM_Tune_TimeLimit                          1999999999.9919999
CPXPARAM_MIP_Tolerances_AbsMIPGap                0
CPXPARAM_MIP_Tolerances_MIPGap                   0
CPXPARAM_WorkDir                                 "/Users/walter/Desktop/grad_research/miro_app/gerry_mandering_MIRO/225a/"
Tried aggregator 1 time.
MIP Presolve eliminated 95 rows and 7 columns.
MIP Presolve modified 234 coefficients.
Reduced MIP has 636 rows, 330 columns, and 4155 nonzeros.
Reduced MIP has 138 binaries, 0 generals, 0 SOSs, and 0 indicators.
Presolve time = 0.01 sec. (3.57 ticks)
Found incumbent of value 100.000000 after 0.02 sec. (6.88 ticks)
Probing time = 0.00 sec. (1.26 ticks)
Tried aggregator 1 time.
Detecting symmetries...
Reduced MIP has 636 rows, 330 columns, and 4155 nonzeros.
Reduced MIP has 138 binaries, 0 generals, 0 SOSs, and 0 indicators.
Presolve time = 0.00 sec. (2.09 ticks)
Probing time = 0.00 sec. (1.25 ticks)
Clique table members: 423.
MIP emphasis: balance optimality and feasibility.
MIP search method: dynamic search.
Parallel mode: none, using 1 thread.
Tried aggregator 1 time.
No LP presolve or aggregator reductions.
Presolve time = 0.00 sec. (0.32 ticks)
Initializing dual steep norms . . .
Root relaxation solution time = 0.00 sec. (0.82 ticks)
        Nodes                                         Cuts/
   Node  Left     Objective  IInf  Best Integer    Best Bound    ItCnt     Gap
*     0+    0                          100.0000      300.0000           200.00%
Found incumbent of value 100.000000 after 0.05 sec. (14.26 ticks)
      0     0        cutoff            100.0000                      1     --- 
Root node processing (before b&c):
  Real time             =    0.05 sec. (14.29 ticks)
Sequential b&c:
  Real time             =    0.00 sec. (0.00 ticks)
                          ------------
Total (root+branch&cut) =    0.05 sec. (14.29 ticks)
MIP status(101): integer optimal solution
Cplex Time: 0.05sec (det. 14.29 ticks)
Fixing integer variables, and solving final LP...
Version identifier: 12.10.0.0 | 2019-11-26 | 843d4de
CPXPARAM_Advance                                 2
CPXPARAM_Threads                                 1
CPXPARAM_Parallel                                1
CPXPARAM_MIP_Display                             4
CPXPARAM_TimeLimit                               9999999999.9599991
CPXPARAM_Tune_TimeLimit                          1999999999.9919999
CPXPARAM_MIP_Tolerances_AbsMIPGap                0
CPXPARAM_MIP_Tolerances_MIPGap                   0
CPXPARAM_WorkDir                                 "/Users/walter/Desktop/grad_research/miro_app/gerry_mandering_MIRO/225a/"
Tried aggregator 1 time.
LP Presolve eliminated 727 rows and 333 columns.
Aggregator did 4 substitutions.
All rows and columns eliminated.
Presolve time = 0.00 sec. (0.38 ticks)
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.67 ticks)
Proven optimal solution.
MIP Solution:          100.000000    (1 iterations, 0 nodes)
Final Solve:           100.000000    (0 iterations)
Best possible:         100.000000
Absolute gap:            0.000000
Relative gap:            0.000000
--- DICOPT: Starting major iteration 2
--- DICOPT: Setting up next NLP
CONOPT 3         32.2.0 rc62c018 Released Aug 26, 2020 DEG x86 64bit/Mac OS X 
 
 
    C O N O P T 3   version 3.17L
    Copyright (C)   ARKI Consulting and Development A/S
                    Bagsvaerdvej 246 A
                    DK-2880 Bagsvaerd, Denmark
 
 
   Iter Phase Ninf   Infeasibility   RGmax    NSB   Step InItr MX OK
      0   0        1.4210854715E-14 (Input point)
 
                   Pre-triangular equations:   166
                   Post-triangular equations:  0
 
      1   0        0.0000000000E+00 (After pre-processing)
      2   0        0.0000000000E+00 (After scaling)
 
 ** Feasible solution. Value of objective =    100.000000000
 
   Iter Phase Ninf     Objective     RGmax    NSB   Step InItr MX OK
      3   3        1.0000000000E+02 0.0E+00     0 0.0E+00    0 F  T
      4   3        1.0000000000E+02 0.0E+00     0
 
 ** Optimal solution. There are no superbasic variables.
 
--- DICOPT: Checking convergence
--- DICOPT: Setting up next MIP
--- GMO Resort Time 0ms
--- DICOPT: Log File:
 Major Major     Objective    CPU time  Itera- Evaluation Solver
 Step  Iter       Function     (Sec)    tions   Errors
  NLP    1       100.00000      0.04        9      0      conopt
  MIP    1       100.00000      0.07        1      0      cplex
  NLP    2       100.00000<     0.00        4      0      conopt
IBM ILOG CPLEX   32.2.0 rc62c018 Released Aug 26, 2020 DEG x86 64bit/Mac OS X 
--- GAMS/Cplex Link licensed for continuous and discrete problems.
Cplex 12.10.0.0
3: *** Value Error Value brought in range for option "itlim" saw "2147483633"
3: *** Value Error    Value set to 2100000000
Reading data...
Starting Cplex...
Unable to load names.
Version identifier: 12.10.0.0 | 2019-11-26 | 843d4de
CPXPARAM_Advance                                 0
CPXPARAM_Threads                                 1
CPXPARAM_Parallel                                1
CPXPARAM_MIP_Display                             4
CPXPARAM_TimeLimit                               9999999999.8839989
CPXPARAM_Tune_TimeLimit                          1999999999.9767997
CPXPARAM_MIP_Tolerances_AbsMIPGap                0
CPXPARAM_MIP_Tolerances_MIPGap                   0
CPXPARAM_WorkDir                                 "/Users/walter/Desktop/grad_research/miro_app/gerry_mandering_MIRO/225a/"
Tried aggregator 1 time.
MIP Presolve eliminated 91 rows and 3 columns.
MIP Presolve modified 303 coefficients.
Reduced MIP has 642 rows, 336 columns, and 4300 nonzeros.
Reduced MIP has 138 binaries, 0 generals, 0 SOSs, and 0 indicators.
Presolve time = 0.00 sec. (3.96 ticks)
Probing time = 0.00 sec. (1.39 ticks)
Cover probing fixed 0 vars, tightened 3 bounds.
Tried aggregator 1 time.
Detecting symmetries...
Reduced MIP has 642 rows, 336 columns, and 4300 nonzeros.
Reduced MIP has 138 binaries, 3 generals, 0 SOSs, and 0 indicators.
Presolve time = 0.00 sec. (2.13 ticks)
Probing time = 0.00 sec. (1.38 ticks)
Clique table members: 423.
MIP emphasis: balance optimality and feasibility.
MIP search method: dynamic search.
Parallel mode: none, using 1 thread.
Tried aggregator 1 time.
LP Presolve eliminated 0 rows and 2 columns.
Reduced LP has 642 rows, 334 columns, and 4298 nonzeros.
Presolve time = 0.00 sec. (0.44 ticks)
Initializing dual steep norms . . .
Iteration log . . .
Iteration:     1   Scaled dual infeas =            64.000000
Iteration:     6   Dual objective     =           135.648681
Initializing dual steep norms . . .
Root relaxation solution time = 0.00 sec. (1.86 ticks)
        Nodes                                         Cuts/
   Node  Left     Objective  IInf  Best Integer    Best Bound    ItCnt     Gap
      0     0      100.0000    39                    100.0000       39         
*     0+    0                          100.0000      100.0000             0.00%
Found incumbent of value 100.000000 after 0.07 sec. (38.82 ticks)
      0     0        cutoff            100.0000      100.0000       39    0.00%
Elapsed time = 0.07 sec. (38.82 ticks, tree = 0.01 MB, solutions = 1)
Root node processing (before b&c):
  Real time             =    0.07 sec. (38.85 ticks)
Sequential b&c:
  Real time             =    0.00 sec. (0.00 ticks)
                          ------------
Total (root+branch&cut) =    0.07 sec. (38.85 ticks)
MIP status(101): integer optimal solution
Cplex Time: 0.08sec (det. 38.85 ticks)
Fixing integer variables, and solving final LP...
Version identifier: 12.10.0.0 | 2019-11-26 | 843d4de
CPXPARAM_Advance                                 2
CPXPARAM_Threads                                 1
CPXPARAM_Parallel                                1
CPXPARAM_MIP_Display                             4
CPXPARAM_TimeLimit                               9999999999.8839989
CPXPARAM_Tune_TimeLimit                          1999999999.9767997
CPXPARAM_MIP_Tolerances_AbsMIPGap                0
CPXPARAM_MIP_Tolerances_MIPGap                   0
CPXPARAM_WorkDir                                 "/Users/walter/Desktop/grad_research/miro_app/gerry_mandering_MIRO/225a/"
Tried aggregator 1 time.
LP Presolve eliminated 727 rows and 332 columns.
Aggregator did 4 substitutions.
Reduced LP has 2 rows, 3 columns, and 4 nonzeros.
Presolve time = 0.00 sec. (0.40 ticks)
Initializing dual steep norms . . .
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.69 ticks)
Proven optimal solution.
MIP Solution:          100.000000    (39 iterations, 0 nodes)
Final Solve:           100.000000    (0 iterations)
Best possible:         100.000000
Absolute gap:            0.000000
Relative gap:            0.000000
--- DICOPT: Starting major iteration 3
--- DICOPT: Setting up next NLP
CONOPT 3         32.2.0 rc62c018 Released Aug 26, 2020 DEG x86 64bit/Mac OS X 
 
 
    C O N O P T 3   version 3.17L
    Copyright (C)   ARKI Consulting and Development A/S
                    Bagsvaerdvej 246 A
                    DK-2880 Bagsvaerd, Denmark
 
 
   Iter Phase Ninf   Infeasibility   RGmax    NSB   Step InItr MX OK
      0   0        1.4210854715E-14 (Input point)
 
                   Pre-triangular equations:   166
                   Post-triangular equations:  0
 
      1   0        0.0000000000E+00 (After pre-processing)
      2   0        0.0000000000E+00 (After scaling)
 
 ** Feasible solution. Value of objective =    100.000000000
 
   Iter Phase Ninf     Objective     RGmax    NSB   Step InItr MX OK
      3   3        1.0000000000E+02 0.0E+00     0 0.0E+00    0 F  T
      4   3        1.0000000000E+02 0.0E+00     0
 
 ** Optimal solution. There are no superbasic variables.
 
--- DICOPT: Checking convergence
--- DICOPT: Search stopped on worsening of NLP subproblems
--- DICOPT: Log File:
 Major Major     Objective    CPU time  Itera- Evaluation Solver
 Step  Iter       Function     (Sec)    tions   Errors
  NLP    1       100.00000      0.04        9      0      conopt
  MIP    1       100.00000      0.07        1      0      cplex
  NLP    2       100.00000<     0.00        4      0      conopt
  MIP    2       100.00000      0.09       39      0      cplex
  NLP    3       100.00000      0.00        4      0      conopt
--- DICOPT: Terminating...
--- DICOPT: Stopped on NLP worsening
      The search was stopped because the objective function
      of the NLP subproblems started to deteriorate.
--- DICOPT: Best integer solution found: 100.000000
--- Reading solution for model spanning_tree
--- Executing after solve: elapsed 0:00:00.497
--- Gerrymander.gms(163) 4 Mb
--- GDX File /Users/walter/Desktop/grad_research/miro_app/gerry_mandering_MIRO/data_Gerrymander/default.gdx
*** Status: Normal completion
--- Job Gerrymander.gms Stop 02/05/21 02:56:09 elapsed 0:00:00.499
========================
========================TRACE [2021-02-05 02:56:14] Logging facility initialised.
[1] "Installing: devtools"
probando la URL 'https://cloud.r-project.org/bin/macosx/contrib/4.0/devtools_2.3.2.tgz'
Content type 'application/x-gzip'
Content type 'application/x-gzip' length 337605 bytes (329 KB)
==
=========================================
==================================================
downloaded 329 KB
The downloaded binary packages are in
	/var/folders/_v/4f8gt7jd161cxvnxqbm3bkgc0000gn/T//Rtmpq2X0An/downloaded_packages
[1] "Installing: rjson"
probando la URL 'https://cloud.r-project.org/bin/macosx/contrib/4.0/rjson_0.2.20.tgz'
Content type 'application/x-gzip' length 191510 bytes (187 KB)
========
==================================================
downloaded 187 KB
The downloaded binary packages are in
	/var/folders/_v/4f8gt7jd161cxvnxqbm3bkgc0000gn/T//Rtmpq2X0An/downloaded_packages
DEBUG [2021-02-05 02:56:20] Database connection established.
DEBUG [2021-02-05 02:56:20] Access Control initialised.
DEBUG [2021-02-05 02:56:20] Db: Data was imported from table: '_sys__data_hashes' (Db.importDataset).
INFO [2021-02-05 02:56:20] Data: 'default.gdx' skipped because it has not changed since the last start.
========================================================
INFO [2021-02-05 02:56:24] Session started (model: 'gerrymander', user: 'walter', workdir: '/Users/walter/Desktop/grad_research/miro_app/gerry_mandering_MIRO').
DEBUG [2021-02-05 02:56:24] Working directory was created: '/Users/walter/Desktop/grad_research/miro_app/gerry_mandering_MIRO'.
DEBUG [2021-02-05 02:56:26] Sidebar menu item: 'inputData' selected.
DEBUG [2021-02-05 02:56:28] walter: Import input data button clicked.
DEBUG [2021-02-05 02:56:28] Db: Data was imported from table: '_sys_metadata_gerrymander' (Db.importDataset).
DEBUG [2021-02-05 02:56:30] Confirm load scenario button clicked.
DEBUG [2021-02-05 02:56:30] Loading and rendering scenarios: '1'.
DEBUG [2021-02-05 02:56:30] Db: Data was imported from table: 'gerrymander_assign_result' (Db.importDataset).
DEBUG [2021-02-05 02:56:30] Db: Data was imported from table: 'gerrymander_nodes' (Db.importDataset).
DEBUG [2021-02-05 02:56:30] Db: Data was imported from table: 'gerrymander_foo' (Db.importDataset).
DEBUG [2021-02-05 02:56:30] Db: Data was imported from table: 'gerrymander_num' (Db.importDataset).
DEBUG [2021-02-05 02:56:30] Db: Data was imported from table: 'gerrymander__scalars' (Db.importDataset).
DEBUG [2021-02-05 02:56:30] Db: A table named: '_sys_scripts_gerrymander' does not exist in the database (Db.importDataset).
DEBUG [2021-02-05 02:56:30] Db: A table named: '_sys_views_gerrymander' does not exist in the database (Db.importDataset).
DEBUG [2021-02-05 02:56:30] Scenario: 'New Scenario' closed.
DEBUG [2021-02-05 02:56:31] Db: Data was imported from table: '_sys_metadata_gerrymander' (Db.importDataset).
DEBUG [2021-02-05 02:56:31] Db: Data was imported from table: '_sys_scenlocks_gerrymander' (Db.importDataset).
DEBUG [2021-02-05 02:56:31] Db: 1 rows in table: '_sys_scenlocks_gerrymander' were deleted. (Db.deleteRows)
DEBUG [2021-02-05 02:56:31] Db: walter: Lock was added for scenario: '1' (Scenario.lock).
DEBUG [2021-02-05 02:56:31] Dataset: nodes loaded successfully (mode: scen, overwrite: FALSE)
DEBUG [2021-02-05 02:56:31] Dataset: foo loaded successfully (mode: scen, overwrite: FALSE)
DEBUG [2021-02-05 02:56:31] Dataset: num loaded successfully (mode: scen, overwrite: FALSE)
 *** caught segfault ***
address 0x18, cause 'memory not mapped'
Traceback:
 1: rjson::fromJSON(file = url)
 2: module(childScope$input, childScope$output, childScope, ...)
 3: force(expr)
 4: domain$wrapSync(expr)
 5: promises::with_promise_domain(createVarPromiseDomain(.globals,     "domain", domain), expr)
 6: withReactiveDomain(childScope, {    if (!is.function(module)) {        stop("module argument must be a function")    }    module(childScope$input, childScope$output, childScope, ...)})
 7: callModule(customRenderer, "custom", data, options = customOptions,     path = customRendererDir, rendererEnv = rendererEnv, views = views,     attachments = attachments)
 8: doTryCatch(return(expr), name, parentenv, handler)
 9: tryCatchOne(expr, names, parentenv, handlers[[1L]])
10: tryCatchList(expr, classes, parentenv, handlers)
11: tryCatch({    callModule(customRenderer, "custom", data, options = customOptions,         path = customRendererDir, rendererEnv = rendererEnv,         views = views, attachments = attachments)}, error = function(e) {    stop(sprintf("An error occured in the custom renderer function: '%s'. Error message: %s.",         typeCustom, e), call. = FALSE)})
12: module(childScope$input, childScope$output, childScope, ...)
13: force(expr)
14: domain$wrapSync(expr)
15: promises::with_promise_domain(createVarPromiseDomain(.globals,     "domain", domain), expr)
16: withReactiveDomain(childScope, {    if (!is.function(module)) {        stop("module argument must be a function")    }    module(childScope$input, childScope$output, childScope, ...)})
17: callModule(renderData, "tab_" %+% i, type = configGraphsOut[[i]]$outType,     data = rendererData, configData = scalarData[["scen_1_"]],     dtOptions = configGraphsOut[[i]]$datatable, graphOptions = configGraphsOut[[i]]$graph,     pivotOptions = configGraphsOut[[i]]$pivottable, customOptions = configGraphsOut[[i]]$options,     roundPrecision = roundPrecision, modelDir = modelDir, rendererEnv = rendererEnv$output,     views = views, attachments = attachments)
18: doTryCatch(return(expr), name, parentenv, handler)
19: tryCatchOne(expr, names, parentenv, handlers[[1L]])
20: tryCatchList(expr, classes, parentenv, handlers)
21: tryCatch({    if (length(configGraphsOut[[i]]$additionalData)) {        additionalOutputIds <- match(configGraphsOut[[i]]$additionalData,             names(modelOut))        additionalOutputIdsNA <- is.na(additionalOutputIds)        if (any(additionalOutputIdsNA)) {            additionalInputIds <- match(configGraphsOut[[i]]$additionalData[additionalOutputIdsNA],                 modelInFileNames)            additionalOutputIds <- c(i, additionalOutputIds[!additionalOutputIdsNA])            rendererData <- scenData[["scen_1_"]][c(additionalOutputIds,                 additionalInputIds + length(modelOut))]            names(rendererData) <- c(names(modelOut)[additionalOutputIds],                 modelInFileNames[additionalInputIds])        }        else {            additionalOutputIds <- c(i, additionalOutputIds)            rendererData <- scenData[["scen_1_"]][additionalOutputIds]            names(rendererData) <- names(modelOut)[additionalOutputIds]        }    }    else {        rendererData <- scenData[["scen_1_"]][[i]]    }    callModule(renderData, "tab_" %+% i, type = configGraphsOut[[i]]$outType,         data = rendererData, configData = scalarData[["scen_1_"]],         dtOptions = configGraphsOut[[i]]$datatable, graphOptions = configGraphsOut[[i]]$graph,         pivotOptions = configGraphsOut[[i]]$pivottable, customOptions = configGraphsOut[[i]]$options,         roundPrecision = roundPrecision, modelDir = modelDir,         rendererEnv = rendererEnv$output, views = views, attachments = attachments)    callModule(renderData, "table-out_" %+% i, type = "datatable",         data = scenData[["scen_1_"]][[i]], dtOptions = configGraphsOut[[i]]$datatable,         roundPrecision = roundPrecision)}, error = function(e) {    flog.error("Problems rendering output charts/tables of dataset: '%s'. Error message: %s.",         modelOutAlias[i], e)    errMsg <<- paste(errMsg, sprintf(lang$errMsg$renderTable$desc,         modelOutAlias[i]), sep = "\n")    showEl(session, paste0("#tab_", i, "-noData"))    hideEl(session, paste0("#tab_", i, "-data"))})
22: FUN(X[[i]], ...)
23: lapply(unlist(outputTabs, use.names = FALSE), function(i) {    tryCatch({        if (length(configGraphsOut[[i]]$additionalData)) {            additionalOutputIds <- match(configGraphsOut[[i]]$additionalData,                 names(modelOut))            additionalOutputIdsNA <- is.na(additionalOutputIds)            if (any(additionalOutputIdsNA)) {                additionalInputIds <- match(configGraphsOut[[i]]$additionalData[additionalOutputIdsNA],                   modelInFileNames)                additionalOutputIds <- c(i, additionalOutputIds[!additionalOutputIdsNA])                rendererData <- scenData[["scen_1_"]][c(additionalOutputIds,                   additionalInputIds + length(modelOut))]                names(rendererData) <- c(names(modelOut)[additionalOutputIds],                   modelInFileNames[additionalInputIds])            }            else {                additionalOutputIds <- c(i, additionalOutputIds)                rendererData <- scenData[["scen_1_"]][additionalOutputIds]                names(rendererData) <- names(modelOut)[additionalOutputIds]            }        }        else {            rendererData <- scenData[["scen_1_"]][[i]]        }        callModule(renderData, "tab_" %+% i, type = configGraphsOut[[i]]$outType,             data = rendererData, configData = scalarData[["scen_1_"]],             dtOptions = configGraphsOut[[i]]$datatable, graphOptions = configGraphsOut[[i]]$graph,             pivotOptions = configGraphsOut[[i]]$pivottable, customOptions = configGraphsOut[[i]]$options,             roundPrecision = roundPrecision, modelDir = modelDir,             rendererEnv = rendererEnv$output, views = views,             attachments = attachments)        callModule(renderData, "table-out_" %+% i, type = "datatable",             data = scenData[["scen_1_"]][[i]], dtOptions = configGraphsOut[[i]]$datatable,             roundPrecision = roundPrecision)    }, error = function(e) {        flog.error("Problems rendering output charts/tables of dataset: '%s'. Error message: %s.",             modelOutAlias[i], e)        errMsg <<- paste(errMsg, sprintf(lang$errMsg$renderTable$desc,             modelOutAlias[i]), sep = "\n")        showEl(session, paste0("#tab_", i, "-noData"))        hideEl(session, paste0("#tab_", i, "-data"))    })    progress$inc(1/length(modelOut), detail = paste0(lang$progressBar$renderOutput$progress,         i))})
24: renderOutputData(rendererEnv, views)
25: observeEventHandler(...)
26: ..stacktraceon..(observeEventHandler(...))
27: handlerFunc()
28: ..stacktraceon..(expr)
29: contextFunc()
30: env$runWith(self, func)
31: force(expr)
32: domain$wrapSync(expr)
33: promises::with_promise_domain(createVarPromiseDomain(.globals,     "domain", domain), expr)
34: withReactiveDomain(.domain, {    env <- .getReactiveEnvironment()    rLog$enter(.reactId, id, .reactType, .domain)    on.exit(rLog$exit(.reactId, id, .reactType, .domain), add = TRUE)    env$runWith(self, func)})
35: domain$wrapSync(expr)
36: promises::with_promise_domain(reactivePromiseDomain(), {    withReactiveDomain(.domain, {        env <- .getReactiveEnvironment()        rLog$enter(.reactId, id, .reactType, .domain)        on.exit(rLog$exit(.reactId, id, .reactType, .domain),             add = TRUE)        env$runWith(self, func)    })})
37: ctx$run(function() {    ..stacktraceon..(expr)})
38: ..stacktraceoff..(ctx$run(function() {    ..stacktraceon..(expr)}))
39: isolate(handlerFunc())
40: func(v$value)
41: withVisible(func(v$value))
42: f(init, x[[i]])
43: Reduce(function(v, func) {    if (".visible" %in% names(formals(func))) {        withVisible(func(v$value, .visible = v$visible))    }    else {        withVisible(func(v$value))    }}, list(...), result)
44: withCallingHandlers(expr, error = doCaptureStack)
45: domain$wrapSync(expr)
46: promises::with_promise_domain(createStackTracePromiseDomain(),     expr)
47: captureStackTraces({    result <- withVisible(force(expr))    if (promises::is.promising(result$value)) {        p <- promise_chain(setVisible(result), ..., catch = catch,             finally = finally)        runFinally <- FALSE        p    }    else {        result <- Reduce(function(v, func) {            if (".visible" %in% names(formals(func))) {                withVisible(func(v$value, .visible = v$visible))            }            else {                withVisible(func(v$value))            }        }, list(...), result)        setVisible(result)    }})
48: doTryCatch(return(expr), name, parentenv, handler)
49: tryCatchOne(expr, names, parentenv, handlers[[1L]])
50: tryCatchList(expr, classes, parentenv, handlers)
51: tryCatch({    captureStackTraces({        result <- withVisible(force(expr))        if (promises::is.promising(result$value)) {            p <- promise_chain(setVisible(result), ..., catch = catch,                 finally = finally)            runFinally <- FALSE            p        }        else {            result <- Reduce(function(v, func) {                if (".visible" %in% names(formals(func))) {                  withVisible(func(v$value, .visible = v$visible))                }                else {                  withVisible(func(v$value))                }            }, list(...), result)            setVisible(result)        }    })}, error = function(e) {    if (!is.null(catch))         catch(e)    else stop(e)}, finally = if (runFinally && !is.null(finally)) finally())
52: do()
53: hybrid_chain({    eventFunc()}, function(value) {    if (ignoreInit && !initialized) {        initialized <<- TRUE        return()    }    if (ignoreNULL && isNullEvent(value)) {        return()    }    if (once) {        on.exit(o$destroy())    }    isolate(handlerFunc())})
54: `<observer:observeEvent(virtualActionButton(rv$btOverwriteScen))>`(...)
55: contextFunc()
56: env$runWith(self, func)
57: force(expr)
58: domain$wrapSync(expr)
59: promises::with_promise_domain(createVarPromiseDomain(.globals,     "domain", domain), expr)
60: withReactiveDomain(.domain, {    env <- .getReactiveEnvironment()    rLog$enter(.reactId, id, .reactType, .domain)    on.exit(rLog$exit(.reactId, id, .reactType, .domain), add = TRUE)    env$runWith(self, func)})
61: domain$wrapSync(expr)
62: promises::with_promise_domain(reactivePromiseDomain(), {    withReactiveDomain(.domain, {        env <- .getReactiveEnvironment()        rLog$enter(.reactId, id, .reactType, .domain)        on.exit(rLog$exit(.reactId, id, .reactType, .domain),             add = TRUE)        env$runWith(self, func)    })})
63: ctx$run(.func)
64: run()
65: withCallingHandlers(expr, error = doCaptureStack)
66: domain$wrapSync(expr)
67: promises::with_promise_domain(createStackTracePromiseDomain(),     expr)
68: captureStackTraces(expr)
69: withCallingHandlers(captureStackTraces(expr), error = function(e) {    if (inherits(e, "shiny.silent.error"))         return()    handle <- getOption("shiny.error")    if (is.function(handle))         handle()})
70: shinyCallingHandlers(run())
71: force(expr)
72: withVisible(force(expr))
73: withCallingHandlers(expr, error = doCaptureStack)
74: domain$wrapSync(expr)
75: promises::with_promise_domain(createStackTracePromiseDomain(),     expr)
76: captureStackTraces({    result <- withVisible(force(expr))    if (promises::is.promising(result$value)) {        p <- promise_chain(setVisible(result), ..., catch = catch,             finally = finally)        runFinally <- FALSE        p    }    else {        result <- Reduce(function(v, func) {            if (".visible" %in% names(formals(func))) {                withVisible(func(v$value, .visible = v$visible))            }            else {                withVisible(func(v$value))            }        }, list(...), result)        setVisible(result)    }})
77: doTryCatch(return(expr), name, parentenv, handler)
78: tryCatchOne(expr, names, parentenv, handlers[[1L]])
79: tryCatchList(expr, classes, parentenv, handlers)
80: tryCatch({    captureStackTraces({        result <- withVisible(force(expr))        if (promises::is.promising(result$value)) {            p <- promise_chain(setVisible(result), ..., catch = catch,                 finally = finally)            runFinally <- FALSE            p        }        else {            result <- Reduce(function(v, func) {                if (".visible" %in% names(formals(func))) {                  withVisible(func(v$value, .visible = v$visible))                }                else {                  withVisible(func(v$value))                }            }, list(...), result)            setVisible(result)        }    })}, error = function(e) {    if (!is.null(catch))         catch(e)    else stop(e)}, finally = if (runFinally && !is.null(finally)) finally())
81: do()
82: hybrid_chain({    if (!.destroyed) {        shinyCallingHandlers(run())    }}, catch = function(e) {    if (inherits(e, "shiny.silent.error")) {        return()    }    printError(e)    if (!is.null(.domain)) {        .domain$unhandledError(e)    }}, finally = .domain$decrementBusyCount)
83: flushCallback()
84: FUN(X[[i]], ...)
85: lapply(.flushCallbacks, function(flushCallback) {    flushCallback()})
86: ctx$executeFlushCallbacks()
87: .getReactiveEnvironment()$flush()
88: flushReact()
89: serviceApp()
90: ..stacktracefloor..(serviceApp())
91: withCallingHandlers(expr, error = doCaptureStack)
92: domain$wrapSync(expr)
93: promises::with_promise_domain(createStackTracePromiseDomain(),     expr)
94: captureStackTraces({    while (!.globals$stopped) {        ..stacktracefloor..(serviceApp())    }})
95: ..stacktraceoff..(captureStackTraces({    while (!.globals$stopped) {        ..stacktracefloor..(serviceApp())    }}))
96: shiny::runApp(Sys.getenv("RE_SHINY_PATH"), host = "127.0.0.1",     launch.browser = identical(Sys.getenv("LAUNCHINBROWSER"),         "true"), port = as.integer(Sys.getenv("RE_SHINY_PORT")))
97: withCallingHandlers(expr, message = function(c) if (inherits(c,     classes)) tryInvokeRestart("muffleMessage"))
98: suppressMessages(shiny::runApp(Sys.getenv("RE_SHINY_PATH"), host = "127.0.0.1",     launch.browser = identical(Sys.getenv("LAUNCHINBROWSER"),         "true"), port = as.integer(Sys.getenv("RE_SHINY_PORT"))))
An irrecoverable exception occurred. R is aborting now ...
